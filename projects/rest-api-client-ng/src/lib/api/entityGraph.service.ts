/**
 * Senzing REST API
 * This is the Senzing REST API.  It describes the REST interface to Senzing API functions available via REST.  It leverages the Senzing native API which is documented at [https://docs.senzing.com](https://docs.senzing.com). <br><br> <b>SSE NOTE:</b> Some end-points described here will indicate \"(Supports SSE)\" to indicate that they support \"Server-sent Events\" via the `text/event-stream` media type.  This support is activated by adding the `Accept: text/event-stream` header to a request to override the default `application/json` media type.  Further, the end-point will behave similarly to its standard operation but will produce `progress` events at regular intervals that are equivalent to its `200` response schema. Upon success, the final event will be `completed` with the same response schema as a `200` response.  Upon failure, the final event will be `failed` with same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`) <br><br> <b>WEB SOCKETS NOTE:</b> Some end-points described here will indicate \"(Supports WebSockets)\" to indicate that they can invoked via the Web Sockets protocol. This support is activated by invoking the end-point using the `ws://` protocol in the URL.  Any request query parameters can still be sent on the URL and the request body can be sent as one or more message from the client (as documented).  The end-point response will be sent as one or more response messages as documented (sometimes describing progress as with SSE end-points).  Upon failure responses will follow the same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`)
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { SzEntityIdentifier } from '../model/szEntityIdentifier';
import { SzEntityIdentifiers } from '../model/szEntityIdentifiers';
import { SzEntityNetworkResponse } from '../model/szEntityNetworkResponse';
import { SzEntityPathResponse } from '../model/szEntityPathResponse';
import { SzErrorResponse } from '../model/szErrorResponse';
import { SzFeatureMode } from '../model/szFeatureMode';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class EntityGraphService {
    protected _basePath     = '/';
    public configuration    = new Configuration();
    private _defaultHeaders = new HttpHeaders();
    /**
     * get the basePath from the configuration instance
     * or alternatively fallback to local reference
     */
    public get basePath(): string {
        return this.configuration && this.configuration.basePath ? this.configuration.basePath : this._basePath;
    }
    /**
     * set the local basePath reference
     */
    public set basePath(value: string) {
        this._basePath = value;
    }
    /**
     * get additional headers so we can add them to the default request headers
     */
    private get additionalHeaders(): {[key: string]: string} | undefined {
        return this.configuration && this.configuration.additionalHeaders ? this.configuration.additionalHeaders : undefined;
    }
    /** 
     * the default headers for http requests
     * including any additional headers added to configuration
    */
    public get defaultHeaders() {
        let retVal = this._defaultHeaders;
        let _additionalHeaders = this.additionalHeaders;
        // if additional headers specified merge with defaults
        if(_additionalHeaders) {
            for(let _hKey in _additionalHeaders) {
                retVal = retVal.set(_hKey, _additionalHeaders[_hKey]);
            }
        }
        return retVal;
    }
    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Finds the entity network around one or more entities.
     * This operation finds the entity network around one or more entities. This attempts to find paths between the specified entities.  If no paths exist, then island networks are returned with each island network containing up to a specified number of related entities.  The entities are identified by their entity IDs or by data source code and record ID pairs for constituent records of those entities.  **NOTE:** If the first entity is identified by entity ID then the subsequent entities must also be identified entity ID.  Similarly, if the first entity is identified by the data source code and record ID of a consistuent record then the subsequent entities must also be identified by the data source code and record ID of constituent records.  **ALSO NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve. 
     * @param e Repeating query parameter containing &#x60;SzEntityIdentifier&#x60; definitions that identify entities to be included in the entity network.  The entity identifiers are either all 64-bit long integers representing entity IDs or they are all encoded &#x60;SzRecordId&#x60; instances identifying records that are part of the resolved entities to avoid.  At least one entity identifier is required.  If both this parameter and the &#x60;entities&#x60; parameter are specified then the values are merged. NOTE: An encoded SzRecordId can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param entities Single query parameter containing multiple SzEntityIdentifier definitions that identify entities to be included in the entity network as a JSON array or a simple comma-separated array.  The entity identifiers are either all 64-bit long integers representing entity IDs or they are all encoded &#x60;SzRecordId&#x60; instances identifying records that are part of the resolved entities to avoid.  At least one entity identifier is required.  If both this parameter and one or more &#x60;e&#x60; parameters are specified then the values are merged. NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param maxDegrees The maximum number of degrees to look for a path between the specified entities.  If not specified, this defaults to &#x60;3&#x60;.
     * @param buildOut The maximum number of degrees to build out around each of the specified entities regardless of those entities being on the path between entities.  The number of entities built out is limited by the &#x60;maxEntities&#x60; parameter.  This defaults to &#x60;1&#x60; degree if not specified.
     * @param maxEntities The maximum number of entities to build out when the &#x60;buildOut&#x60; is greater than zero (0).  This defaults to &#x60;1000&#x60; if not specified.
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - Group near-duplicate feature values and return                         a representative value along with its near                         duplicate values.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether or not to force the minimum entity detail in the response which may consist of nothing more than an entity ID.  This provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  This overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findEntityNetwork(e?: Array<SzEntityIdentifier>, entities?: SzEntityIdentifiers, maxDegrees?: number, buildOut?: number, maxEntities?: number, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityNetworkResponse>;
    public findEntityNetwork(e?: Array<SzEntityIdentifier>, entities?: SzEntityIdentifiers, maxDegrees?: number, buildOut?: number, maxEntities?: number, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityNetworkResponse>>;
    public findEntityNetwork(e?: Array<SzEntityIdentifier>, entities?: SzEntityIdentifiers, maxDegrees?: number, buildOut?: number, maxEntities?: number, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityNetworkResponse>>;
    public findEntityNetwork(e?: Array<SzEntityIdentifier>, entities?: SzEntityIdentifiers, maxDegrees?: number, buildOut?: number, maxEntities?: number, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (e) {
            e.forEach((element) => {
                queryParameters = queryParameters.append('e', <any>element);
            })
        }
        if (entities !== undefined && entities !== null) {
            queryParameters = queryParameters.set('entities', <any>entities);
        }
        if (maxDegrees !== undefined && maxDegrees !== null) {
            queryParameters = queryParameters.set('maxDegrees', <any>maxDegrees);
        }
        if (buildOut !== undefined && buildOut !== null) {
            queryParameters = queryParameters.set('buildOut', <any>buildOut);
        }
        if (maxEntities !== undefined && maxEntities !== null) {
            queryParameters = queryParameters.set('maxEntities', <any>maxEntities);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityNetworkResponse>('get',`${this.basePath}/entity-networks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finds a path between two entities identified by entity ID or by data sources and record IDs of constituent records.
     * This operation finds the path between two entities and returns a description of that entity path (if any) or a response indicating that there is no path between the entities.  The subject entities are either identfieid by entity ID or by data source code and record ID pairs for constituent records of those entities.  **NOTE:** If the first entity is identified by entity ID then the second must also be identified an entity ID.  Similarly, if the first entity is identified by data source code and record ID then the second must also be identified by data source code and record ID.  **ALSO NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve. 
     * @param from The &#x60;SzEntityIdentifier&#x60; for the first entity for the path either as an entity ID or an encoded &#x60;SzRecordId&#x60; for the constituent record. Whatever format is used for the \&quot;from\&quot; parameter must match the format of the \&quot;to\&quot; parameter.  NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param to The &#x60;SzEntityIdentifier&#x60; for the last entity for the path either as an entity ID or a encoded &#x60;SzRecordId&#x60; for the constituent record. Whatever format is used for the \&quot;to\&quot; parameter must match the format of the \&quot;from\&quot; parameter.  NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param maxDegrees The maximum number of degrees to look for a path from the first entity to the last entity.  This defaults to &#x60;3&#x60; if not specified.
     * @param x Repeating query parameter containing &#x60;SzEntityIdentifier&#x60; definitions that identify entities to be avoided or forbidden from the path (depending on the forbidAvoided parameter).  The entity identifiers are either all 64-bit long integers representing entity IDs or they are all encoded SzRecordId instances identifying records that are part of the resolved entities to exclude.  If this parameter is not provided, then the default is to NOT exclude any entities.  If both this parameter and the &#x60;avoidEntities&#x60; parameter are specified then the values are merged.  NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param avoidEntities Single query parameter containing multiple &#x60;SzEntityIdentifier&#x60; definitions as a JSON array or a simple comma-separated array that identify entities to be avoided or forbidden from the path (depending on the forbidAvoided parameter).  The entity identifiers are either all 64-bit long integers representing entity IDs or they are all encoded &#x60;SzRecordId&#x60; instances identifying records that are part of the resolved entities to exclude.  At least one entity identifier is required.  If both this parameter and one or more &#x60;x&#x60; parameters are specified then the values are merged.  NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param forbidAvoided If the avoidEntities parameter is provided then this flag is used to control whether or not to forbid the avoided entities rather than include them in the path as a \&quot;last resort\&quot;.
     * @param s The multi-valued query parameter where each value is a data source code identifying data sources for which one must be included in the entities for the path.  If not provided, then the default is to NOT require any specific data sources.
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - Group near-duplicate feature values and return                         a representative value along with its near                         duplicate values.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether or not to force the minimum entity detail in the response which may consist of nothing more than an entity ID.  This provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  This overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findEntityPath(from: SzEntityIdentifier, to: SzEntityIdentifier, maxDegrees?: number, x?: Array<SzEntityIdentifier>, avoidEntities?: SzEntityIdentifiers, forbidAvoided?: boolean, s?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityPathResponse>;
    public findEntityPath(from: SzEntityIdentifier, to: SzEntityIdentifier, maxDegrees?: number, x?: Array<SzEntityIdentifier>, avoidEntities?: SzEntityIdentifiers, forbidAvoided?: boolean, s?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityPathResponse>>;
    public findEntityPath(from: SzEntityIdentifier, to: SzEntityIdentifier, maxDegrees?: number, x?: Array<SzEntityIdentifier>, avoidEntities?: SzEntityIdentifiers, forbidAvoided?: boolean, s?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityPathResponse>>;
    public findEntityPath(from: SzEntityIdentifier, to: SzEntityIdentifier, maxDegrees?: number, x?: Array<SzEntityIdentifier>, avoidEntities?: SzEntityIdentifiers, forbidAvoided?: boolean, s?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling findEntityPath.');
        }

        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling findEntityPath.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (from !== undefined && from !== null) {
            queryParameters = queryParameters.set('from', <any>from);
        }
        if (to !== undefined && to !== null) {
            queryParameters = queryParameters.set('to', <any>to);
        }
        if (maxDegrees !== undefined && maxDegrees !== null) {
            queryParameters = queryParameters.set('maxDegrees', <any>maxDegrees);
        }
        if (x && x !== undefined && x !== null && x.forEach) {
            x.forEach((element) => {
                queryParameters = queryParameters.append('x', <any>element);
            })
        }
        if (avoidEntities !== undefined && avoidEntities !== null) {
            queryParameters = queryParameters.set('avoidEntities', <any>avoidEntities);
        }
        if (forbidAvoided !== undefined && forbidAvoided !== null) {
            queryParameters = queryParameters.set('forbidAvoided', <any>forbidAvoided);
        }
        if (s) {
            s.forEach((element) => {
                queryParameters = queryParameters.append('s', <any>element);
            })
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityPathResponse>('get',`${this.basePath}/entity-paths`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
