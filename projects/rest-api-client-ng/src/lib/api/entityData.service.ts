/**
 * Senzing REST API
 * This is the Senzing REST API.  It describes the REST interface to Senzing API functions available via REST.  It leverages the Senzing native API which is documented at [https://docs.senzing.com](https://docs.senzing.com). <br><br> <b>SSE NOTE:</b> Some end-points described here will indicate \"(Supports SSE)\" to indicate that they support \"Server-sent Events\" via the `text/event-stream` media type.  This support is activated by adding the `Accept: text/event-stream` header to a request to override the default `application/json` media type.  Further, the end-point will behave similarly to its standard operation but will produce `progress` events at regular intervals that are equivalent to its `200` response schema. Upon success, the final event will be `completed` with the same response schema as a `200` response.  Upon failure, the final event will be `failed` with same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`) <br><br> <b>WEB SOCKETS NOTE:</b> Some end-points described here will indicate \"(Supports WebSockets)\" to indicate that they can invoked via the Web Sockets protocol. This support is activated by invoking the end-point using the `ws://` protocol in the URL.  Any request query parameters can still be sent on the URL and the request body can be sent as one or more message from the client (as documented).  The end-point response will be sent as one or more response messages as documented (sometimes describing progress as with SSE end-points).  Upon failure responses will follow the same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`)
 *
 * OpenAPI spec version: 3.3.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { SzAttributeSearchResponse } from '../model/szAttributeSearchResponse';
import { SzAttributeSearchResultType } from '../model/szAttributeSearchResultType';
import { SzDeleteRecordResponse } from '../model/szDeleteRecordResponse';
import { SzDetailLevel } from '../model/szDetailLevel';
import { SzEntityResponse } from '../model/szEntityResponse';
import { SzErrorResponse } from '../model/szErrorResponse';
import { SzFeatureMode } from '../model/szFeatureMode';
import { SzHowEntityResponse } from '../model/szHowEntityResponse';
import { SzLoadRecordResponse } from '../model/szLoadRecordResponse';
import { SzRecordIdentifier } from '../model/szRecordIdentifier';
import { SzRecordIdentifiers } from '../model/szRecordIdentifiers';
import { SzRecordResponse } from '../model/szRecordResponse';
import { SzReevaluateResponse } from '../model/szReevaluateResponse';
import { SzRelationshipMode } from '../model/szRelationshipMode';
import { SzVirtualEntityResponse } from '../model/szVirtualEntityResponse';
import { SzWhyEntitiesResponse } from '../model/szWhyEntitiesResponse';
import { SzWhyEntityResponse } from '../model/szWhyEntityResponse';
import { SzWhyRecordsResponse } from '../model/szWhyRecordsResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class EntityDataService {
    protected _basePath     = '/';
    public configuration    = new Configuration();
    private _defaultHeaders = new HttpHeaders();
    /**
     * get the basePath from the configuration instance
     * or alternatively fallback to local reference
     */
    public get basePath(): string {
        return this.configuration && this.configuration.basePath ? this.configuration.basePath : this._basePath;
    }
    /**
     * set the local basePath reference
     */
    public set basePath(value: string) {
        this._basePath = value;
    }
    /**
     * get additional headers so we can add them to the default request headers
     */
    private get additionalHeaders(): {[key: string]: string} | undefined {
        return this.configuration && this.configuration.additionalHeaders ? this.configuration.additionalHeaders : undefined;
    }
    /** 
     * the default headers for http requests
     * including any additional headers added to configuration
    */
    public get defaultHeaders() {
        let retVal = this._defaultHeaders;
        let _additionalHeaders = this.additionalHeaders;
        // if additional headers specified merge with defaults
        if(_additionalHeaders) {
            for(let _hKey in _additionalHeaders) {
                retVal = retVal.set(_hKey, _additionalHeaders[_hKey]);
            }
        }
        return retVal;
    }
    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Load a new record or replace a record in a data source with a specific record ID.
     * This operation loads a single record using the data source identified by the data source code in the request path.  The record will be identified uniquely within the data source by the record ID provided in the request path.  The provided record in the request body is described in JSON using the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The provided JSON record may omit the &#x60;RECORD_ID&#x60;, but if it contains a &#x60;RECORD_ID&#x60; then it **must** match the record ID provided on the request path.  The record ID is returned as part of the response.  **NOTE:** The &#x60;withInfo&#x60; parameter will return the entity resolution info pertaining to the load.  This can be used to update a search index or external data mart.   Additionally, Senzing API Server provides a means to have the \&quot;raw\&quot; entity resolution info (from the underlying native Senzing API) automatically sent to a messaging service such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the &#x60;withInfo&#x60; query parameter value. 
     * @param body The record data as JSON.  The format of the JSON is described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The specified JSON may include or exclude the DATA_SOURCE and RECORD_ID fields.  Any excluded field will be added to the JSON accordingly.  Any included field in the JSON, must match the respective path parameter for data source code or record ID.
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param loadId The optional load ID to associate with the loaded record.
     * @param withInfo Set to &#x60;true&#x60; to include resolution information related to loading, and &#x60;false&#x60; to exclude it.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRecord(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzLoadRecordResponse>;
    public addRecord(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzLoadRecordResponse>>;
    public addRecord(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzLoadRecordResponse>>;
    public addRecord(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addRecord.');
        }

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling addRecord.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling addRecord.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (loadId !== undefined && loadId !== null) {
            queryParameters = queryParameters.set('loadId', <any>loadId);
        }
        if (withInfo !== undefined && withInfo !== null) {
            queryParameters = queryParameters.set('withInfo', <any>withInfo);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<SzLoadRecordResponse>('put',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load a new record specified in a data source with either an auto-generated record ID or a &#x60;RECORD_ID&#x60; specified in the payload.
     * This operation loads a single record using the data source identified by the data source code in the request path.  The provided record in the request body is described in JSON using the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The provided record may contain a &#x60;RECORD_ID&#x60; to identify it uniquely among other records in the same data source, but if it does not then a record ID will be automatically generated.  The record ID is returned as part of the response.  **NOTE:** The &#x60;withInfo&#x60; parameter will return the entity resolution info pertaining to the load.  This can be used to update a search index or external data mart.   Additionally, Senzing API Server provides a means to have the \&quot;raw\&quot; entity resolution info (from the underlying native Senzing API) automatically sent to a messaging service such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the &#x60;withInfo&#x60; query parameter value. 
     * @param body The record data as JSON.  The format of the JSON is described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The specified JSON may include or exclude the DATA_SOURCE field. It will be added if excluded.  If included, it must match the data source code in the path parameters.
     * @param dataSourceCode The data source code identifying the data source.
     * @param loadId The optional load ID to associate with the loaded record.
     * @param withInfo Set to &#x60;true&#x60; to include resolution information related to loading, and &#x60;false&#x60; to exclude it.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRecordWithReturnedRecordId(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzLoadRecordResponse>;
    public addRecordWithReturnedRecordId(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzLoadRecordResponse>>;
    public addRecordWithReturnedRecordId(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzLoadRecordResponse>>;
    public addRecordWithReturnedRecordId(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addRecordWithReturnedRecordId.');
        }

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling addRecordWithReturnedRecordId.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (loadId !== undefined && loadId !== null) {
            queryParameters = queryParameters.set('loadId', <any>loadId);
        }
        if (withInfo !== undefined && withInfo !== null) {
            queryParameters = queryParameters.set('withInfo', <any>withInfo);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        return this.httpClient.request<SzLoadRecordResponse>('post',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a record given its data source and record ID.
     * This operation deletes a single record identified by the data source code and record ID in the request path.  **NOTE:** The &#x60;withInfo&#x60; parameter will return the entity resolution info pertaining to the delete.  This can be used to update a search index or external data mart.   Additionally, Senzing API Server provides a means to have the \&quot;raw\&quot; entity resolution info (from the underlying native Senzing API) automatically sent to a messaging service such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the &#x60;withInfo&#x60; query parameter value. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param loadId The optional load ID to associate with the loaded record.
     * @param withInfo Set to &#x60;true&#x60; to include resolution information related to loading, and &#x60;false&#x60; to exclude it.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteRecord(dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzDeleteRecordResponse>;
    public deleteRecord(dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzDeleteRecordResponse>>;
    public deleteRecord(dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzDeleteRecordResponse>>;
    public deleteRecord(dataSourceCode: string, recordId: string, loadId?: string, withInfo?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling deleteRecord.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling deleteRecord.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (loadId !== undefined && loadId !== null) {
            queryParameters = queryParameters.set('loadId', <any>loadId);
        }
        if (withInfo !== undefined && withInfo !== null) {
            queryParameters = queryParameters.set('withInfo', <any>withInfo);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzDeleteRecordResponse>('delete',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a resolved entity by entity ID.
     * Gets the details on a resolved entity that is identified by the entity ID specified in the request path.  **NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve.  An alternative way to identify an entity is by one of its constituent records using &#x60;GET /data-sources/{dataSourceCode}/records/{recordId}/entity&#x60;. 
     * @param entityId The unique numeric ID that identifies that entity being requested.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRelated Controls how to handle the first-degree related entities.  The possible values are:   * &#x60;NONE&#x60; - Do not include any data on first-degree related entities --      this is the fastest option from a performance perspective because      related entities do not have to be retrieved.   * &#x60;PARTIAL&#x60; - **(default value)** Include only partial stub      information for related entities with the &#x60;partial&#x60; property of the      &#x60;SzRelatedEntity&#x60; instances set to &#x60;true&#x60;.  Obtaining additional      information requires subsequent API calls.   * &#x60;FULL&#x60; - Include full data on the first-degree related entities      according to the &#x60;featureMode&#x60; and &#x60;detailLevel&#x60; **unless**      &#x60;forceMinimal&#x60; is &#x60;true&#x60;.  This option obtains the entity network      at one degree for the requested entity and will populate up to 1000      related entities as much as possible with respect to the      &#x60;featureMode&#x60; and &#x60;detailLevel&#x60;.  Related entities beyond the first      1000 will be left incomplete and have their &#x60;partial&#x60; property set      to &#x60;true&#x60; regardless of the &#x60;detailLevel&#x60; and &#x60;featureMode&#x60;.  If      this value is specified along with &#x60;forceMinimal&#x3D;true&#x60; then      &#x60;PARTIAL&#x60; is used instead.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityByEntityId(entityId: number, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityResponse>;
    public getEntityByEntityId(entityId: number, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityResponse>>;
    public getEntityByEntityId(entityId: number, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityResponse>>;
    public getEntityByEntityId(entityId: number, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling getEntityByEntityId.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRelated !== undefined && withRelated !== null) {
            queryParameters = queryParameters.set('withRelated', <any>withRelated);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SzEntityResponse>(`${this.basePath}/entities/${encodeURIComponent(String(entityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a resolved entity by data source and record ID.
     * Gets the details on a resolved entity that contains the record identified by the data source code and record ID in the specified request path. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRelated Controls how to handle the first-degree related entities.  The possible values are:   * &#x60;NONE&#x60; - Do not include any data on first-degree related entities --      this is the fastest option from a performance perspective because      related entities do not have to be retrieved.   * &#x60;PARTIAL&#x60; - **(default value)** Include only partial stub      information for related entities with the &#x60;partial&#x60; property of the      &#x60;SzRelatedEntity&#x60; instances set to &#x60;true&#x60;.  Obtaining additional      information requires subsequent API calls.   * &#x60;FULL&#x60; - Include full data on the first-degree related entities      according to the &#x60;featureMode&#x60; and &#x60;detailLevel&#x60; **unless**      &#x60;forceMinimal&#x60; is &#x60;true&#x60;.  This option obtains the entity network      at one degree for the requested entity and will populate up to 1000      related entities as much as possible with respect to the      &#x60;featureMode&#x60; and &#x60;detailLevel&#x60;.  Related entities beyond the first      1000 will be left incomplete and have their &#x60;partial&#x60; property set      to &#x60;true&#x60; regardless of the &#x60;detailLevel&#x60; and &#x60;featureMode&#x60;.  If      this value is specified along with &#x60;forceMinimal&#x3D;true&#x60; then      &#x60;PARTIAL&#x60; is used instead.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityByRecordId(dataSourceCode: string, recordId: string, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityResponse>;
    public getEntityByRecordId(dataSourceCode: string, recordId: string, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityResponse>>;
    public getEntityByRecordId(dataSourceCode: string, recordId: string, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityResponse>>;
    public getEntityByRecordId(dataSourceCode: string, recordId: string, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelated?: SzRelationshipMode, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getEntityByRecordId.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling getEntityByRecordId.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRelated !== undefined && withRelated !== null) {
            queryParameters = queryParameters.set('withRelated', <any>withRelated);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityResponse>('get',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}/entity`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get an entity record by data source and record ID.
     * Gets details on a specific entity record identified by the data source code and record ID specified in the request path. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRecord(dataSourceCode: string, recordId: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzRecordResponse>;
    public getRecord(dataSourceCode: string, recordId: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzRecordResponse>>;
    public getRecord(dataSourceCode: string, recordId: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzRecordResponse>>;
    public getRecord(dataSourceCode: string, recordId: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getRecord.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling getRecord.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRecordResponse>('get',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Builds a virtual entity by simulating the resolution of the records identified by the specified record ID parameters.
     * This operation simulates the resolution of the one or more specified records into a single entity and returns the simulated \&quot;virtual\&quot; entity.  The subject records are identified by data source code and record ID pairs. 
     * @param r Repeating query parameter containing encoded &#x60;SzRecordId&#x60; definitions that identify records to be inclued in the resultant virtual entity.  At least one record identifier is required.  If both this parameter and the &#x60;records&#x60; parameter are specified then the values are merged. **NOTE**: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainer is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param records Singular query parameter containing multiple encoded &#x60;SzRecordId&#x60; definitions that identify records to be inclued in the resultant virtual entity as a JSON array or a simple comma-separated array. At least one record identifier is required.  If both this parameter and the &#x60;r&#x60; parameter are specified then the values are merged. **NOTE**: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainer is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVirtualEntityByRecordIds(r?: Array<SzRecordIdentifier>, records?: SzRecordIdentifiers, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzVirtualEntityResponse>;
    public getVirtualEntityByRecordIds(r?: Array<SzRecordIdentifier>, records?: SzRecordIdentifiers, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzVirtualEntityResponse>>;
    public getVirtualEntityByRecordIds(r?: Array<SzRecordIdentifier>, records?: SzRecordIdentifiers, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzVirtualEntityResponse>>;
    public getVirtualEntityByRecordIds(r?: Array<SzRecordIdentifier>, records?: SzRecordIdentifiers, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (r) {
            r.forEach((element) => {
                queryParameters = queryParameters.append('r', <any>element);
            })
        }
        if (records !== undefined && records !== null) {
            queryParameters = queryParameters.set('records', <any>records);
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzVirtualEntityResponse>('get',`${this.basePath}/virtual-entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an analysis of how the entity for the respective entity ID resolved.
     * This operation provides an anlysis of how the records in an entity resolved.  The subject entity is identified by the entity ID in the request path.  **NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve.  An alternative way to identify an entity is by one of its constituent records using &#x60;GET /data-sources/{dataSourceCode}/records/{recordId}/entity/how&#x60;. 
     * @param entityId The unique numeric ID that identifies the entity for which to perform the analysis.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public howEntityByEntityID(entityId: number, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzHowEntityResponse>;
    public howEntityByEntityID(entityId: number, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzHowEntityResponse>>;
    public howEntityByEntityID(entityId: number, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzHowEntityResponse>>;
    public howEntityByEntityID(entityId: number, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling howEntityByEntityID.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzHowEntityResponse>('get',`${this.basePath}/entities/${encodeURIComponent(String(entityId))}/how`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an analysis of how the entity for the record with the respective data source code and record ID resolved.
     * This operation provides an anlysis of how the records in an entity resolved.  The subject entity is the one containing the record identified by the data source code and record ID in the request path. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public howEntityByRecordID(dataSourceCode: string, recordId: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzHowEntityResponse>;
    public howEntityByRecordID(dataSourceCode: string, recordId: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzHowEntityResponse>>;
    public howEntityByRecordID(dataSourceCode: string, recordId: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzHowEntityResponse>>;
    public howEntityByRecordID(dataSourceCode: string, recordId: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling howEntityByRecordID.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling howEntityByRecordID.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzHowEntityResponse>('get',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}/entity/how`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reevaluate an entity identified by its entity ID.
     * Reevaluates an entity identified by the entity ID specified via the &#x60;entityId&#x60; query parameter.  **NOTE:** The &#x60;withInfo&#x60; parameter will return the entity resolution info pertaining to the reevaluation.  This can be used to update a search index or external data mart.   Additionally, Senzing API Server provides a means to have the \&quot;raw\&quot; entity resolution info (from the underlying native Senzing API) automatically sent to a messaging service such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the &#x60;withInfo&#x60; query parameter value.  **ALSO NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve. 
     * @param entityId The entity ID of the entity to reevaluate.
     * @param withInfo Set to &#x60;true&#x60; to include resolution information related to loading, and &#x60;false&#x60; to exclude it.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reevaluateEntity(entityId: number, withInfo?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzReevaluateResponse>;
    public reevaluateEntity(entityId: number, withInfo?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzReevaluateResponse>>;
    public reevaluateEntity(entityId: number, withInfo?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzReevaluateResponse>>;
    public reevaluateEntity(entityId: number, withInfo?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling reevaluateEntity.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (entityId !== undefined && entityId !== null) {
            queryParameters = queryParameters.set('entityId', <any>entityId);
        }
        if (withInfo !== undefined && withInfo !== null) {
            queryParameters = queryParameters.set('withInfo', <any>withInfo);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzReevaluateResponse>('post',`${this.basePath}/reevaluate-entity`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reevaluate a record identified by a data source and record ID.
     * This operation reevaluates a single record identified by the data source code and record ID in the request path.  **NOTE:** The &#x60;withInfo&#x60; parameter will return the entity resolution info pertaining to the reevaluation.  This can be used to update a search index or external data mart.   Additionally, Senzing API Server provides a means to have the \&quot;raw\&quot; entity resolution info (from the underlying native Senzing API) automatically sent to a messaging service such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the &#x60;withInfo&#x60; query parameter value. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param withInfo Set to &#x60;true&#x60; to include resolution information related to loading, and &#x60;false&#x60; to exclude it.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reevaluateRecord(dataSourceCode: string, recordId: string, withInfo?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzReevaluateResponse>;
    public reevaluateRecord(dataSourceCode: string, recordId: string, withInfo?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzReevaluateResponse>>;
    public reevaluateRecord(dataSourceCode: string, recordId: string, withInfo?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzReevaluateResponse>>;
    public reevaluateRecord(dataSourceCode: string, recordId: string, withInfo?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling reevaluateRecord.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling reevaluateRecord.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withInfo !== undefined && withInfo !== null) {
            queryParameters = queryParameters.set('withInfo', <any>withInfo);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzReevaluateResponse>('post',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}/reevaluate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for entities that would resolve to or relate to the provided entity features.
     * This operation finds all entities that would resolve or relate to the search candidate features specified by the &#x60;attr&#x60; and/or &#x60;attrs&#x60; query parameters.  The search candidate features are treated as if they belonged to an inbound record being loaded, thus the attribute names are given by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). If including the search candidate features as query parameters presents privacy concerns due to sensitivity of the data, they can alternately be sent in the request body using the &#x60;POST /search-entities&#x60; endpoint.  **NOTE:** This operation differs from a keyword search in that it uses deterministic entity resolution rules to determine the result set.  This means that features that are considered \&quot;generic\&quot; (i.e.: overly common) will be ignored just as they are during entity resolution and will not yield search results.  For example, searching on a gender by itself will return no results rather than half of all entities.  Similarly, a phone number such as &#x60;555-1212&#x60; may yield no results. 
     * @param attrs The JSON record describing the entity attributes in the same format as how an entity record is loaded.  The specified attributes are treated as a hypothetical record being loaded, and the result is anything that would have matched or related to it.  Here are some examples of encoding this parameter:  - **JavaScript Example**   &#x60;&#x60;&#x60;javascript     var searchCriteria &#x3D; {       \&quot;NAME_FULL\&quot;: \&quot;Joe Schmoe\&quot;,       \&quot;DATE_OF_BIRTH\&quot;: \&quot;03-SEP-1987\&quot;     };     var searchAttrs &#x3D; JSON.stringify(searchCriteria);     var urlPath &#x3D; \&quot;/entities?attrs&#x3D;\&quot; + encodeURIComponent(searchAttrs);   &#x60;&#x60;&#x60;  - **Java Example**   &#x60;&#x60;&#x60;java     JsonObjectBuilder builder &#x3D; Json.createObjectBuilder();     builder.add(\&quot;NAME_FULL\&quot;, \&quot;Joe Schmoe\&quot;);     builder.add(\&quot;DATE_OF_BIRTH\&quot;, \&quot;03-SEP-1987\&quot;);     JsonObject searchCriteria &#x3D; builder.build();      String searchAttrs &#x3D; searchCriteria.toString();     String encodedAttrs &#x3D; URLEncoder.encode(searchAttrs, \&quot;UTF-8\&quot;);     String urlPath &#x3D; \&quot;/entities?attrs&#x3D;\&quot; + encodedAttrs;   &#x60;&#x60;&#x60;  In both of the above examples the &#x60;urlPath&#x60; variable is set to: &#x60;&#x60;&#x60;json  /entities?attrs&#x3D;%7B%22NAME_FULL%22%3A%22Joe%20Schmoe%22%2C%22DATE_OF_BIRTH%22%3A%2203-SEP-1987%22%7D  &#x60;&#x60;&#x60; 
     * @param attr Either the &#x60;attrs&#x60; or &#x60;attr&#x60; parameter is required, **however** if the &#x60;attrs&#x60; parameter is provided it takes precedence and the &#x60;attr&#x60; parameter will be ignored.  If you are using this API programmatically then you should typically use the &#x60;attrs&#x60; parameter.  But when manually constructing a URL in the browser address bar, in a command-line tool like &#x60;curl&#x60; or in a REST client browser extension for debugging or testing purposes, encoding that JSON value can be unwieldy.  This parameter (which is multi-valued) lets you specify colon-delimited strings that are prefixed with the JSON property name and suffixed with the value.  For example, &#x60;NAME_FIRST:Joe&#x60; (url encoded of course).  This side-steps the need to URL-encode the structural JSON characters and usually means you need only URL-encode basic characters like colons (&#x60;%3A&#x60;) and spaces (&#x60;%20&#x60;).  The JSON constructed using this parameter is obviously flat.  If you want to group properties together by their \&quot;usage type\&quot; (e.g.: &#x60;NAME_TYPE&#x60;, &#x60;PHONE_TYPE&#x60; or &#x60;ADDRESS_TYPE&#x60;) then you would **also** prefix with the type (e.g.: &#x60;HOME_PHONE_NUMBER:702-555-1212&#x60;).
     * @param includeOnly Optional parameter that can be specified zero or more times to indicate which &#x60;SzAttributeSearchResultType&#x60;&#x27;s should be included in the search results.  If not specified then all match types are included.  *NOTE*: This parameter is ignored unless the underlying native Senzing API is version 2.4.1 or later.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
     public searchEntitiesByGet(attrs?: string, attr?: Array<string>, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzAttributeSearchResponse>;
     public searchEntitiesByGet(attrs?: string, attr?: Array<string>, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzAttributeSearchResponse>>;
     public searchEntitiesByGet(attrs?: string, attr?: Array<string>, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzAttributeSearchResponse>>;
     public searchEntitiesByGet(attrs?: string, attr?: Array<string>, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {
        









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (attrs !== undefined && attrs !== null) {
            queryParameters = queryParameters.set('attrs', <any>attrs);
        }
        if (attr) {
            attr.forEach((element) => {
                queryParameters = queryParameters.append('attr', <any>element);
            })
        }
        if (includeOnly) {
            includeOnly.forEach((includeOnlyEle: SzAttributeSearchResultType) => {
                queryParameters = queryParameters.append('includeOnly', <SzAttributeSearchResultType>includeOnlyEle);
            })
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRelationships !== undefined && withRelationships !== null) {
            queryParameters = queryParameters.set('withRelationships', <any>withRelationships);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzAttributeSearchResponse>('get',`${this.basePath}/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
    /**
     * Search for entities that would match or relate to the provided entity features.  This is similar to &#x60;GET /entities&#x60; except it requires the caller to specify the search criteria as JSON in the request body.
     * This operation finds all entities that would resolve or relate to the search candidate features specified in JSON request body.  The search candidate features are treated as if they belonged to an inbound record being loaded.  The JSON format of the request body is defined by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). This operation is similar to the &#x60;GET /entities&#x60; endpoint in function except that it provides a means to avoid specifying potentially sensitive data in query parameters, but instead in the request body.  **NOTE:** This operation differs from a keyword search in that it uses deterministic entity resolution rules to determine the result set.  This means that features that are considered \&quot;generic\&quot; (i.e.: overly common) will be ignored just as they are during entity resolution and will not yield search results.  For example, searching on a gender by itself will return no results rather than half of all entities.  Similarly, a phone number such as &#x60;555-1212&#x60; may yield no results. 
     * @param body The JSON record describing the entity attributes in the same format as how an entity record is loaded The format of the JSON is described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The specified attributes are treated as a hypothetical record being loaded, and the result is anything that would have matched or related to it.
     * @param includeOnly Optional parameter that can be specified zero or more times to indicate which &#x60;SzAttributeSearchResultType&#x60;&#x27;s should be included in the search results.  If not specified then all match types are included.  *NOTE*: This parameter is ignored unless the underlying native Senzing API is version 2.4.1 or later.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchEntitiesByPost(body: { [key: string]: any; }, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzAttributeSearchResponse>;
    public searchEntitiesByPost(body: { [key: string]: any; }, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzAttributeSearchResponse>>;
    public searchEntitiesByPost(body: { [key: string]: any; }, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzAttributeSearchResponse>>;
    public searchEntitiesByPost(body: { [key: string]: any; }, includeOnly?: Array<SzAttributeSearchResultType>, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchEntitiesByPost.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeOnly) {
            includeOnly.forEach((element) => {
                queryParameters = queryParameters.append('includeOnly', <any>element);
            })
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRelationships !== undefined && withRelationships !== null) {
            queryParameters = queryParameters.set('withRelationships', <any>withRelationships);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<SzAttributeSearchResponse>('post',`${this.basePath}/search-entities`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for entities that would match or relate to the provided entity features.
     *
     * @param attrs The JSON record describing the entity attributes in the same format as how an entity record is loaded.  The specified attributes are treated as a hypothetical record being loaded, and the result is anything that would have matched or related to it.  Here are some examples of encoding this parameter:  - **JavaScript Example**   &#x60;&#x60;&#x60;javascript     var searchCriteria &#x3D; {       \&quot;NAME_FULL\&quot;: \&quot;Joe Schmoe\&quot;,       \&quot;DATE_OF_BIRTH\&quot;: \&quot;03-SEP-1987\&quot;     };     var searchAttrs &#x3D; JSON.stringify(searchCriteria);     var urlPath &#x3D; \&quot;/entities?attrs&#x3D;\&quot; + encodeURIComponent(searchAttrs);   &#x60;&#x60;&#x60;  - **Java Example**   &#x60;&#x60;&#x60;java     JsonObjectBuilder builder &#x3D; Json.createObjectBuilder();     builder.add(\&quot;NAME_FULL\&quot;, \&quot;Joe Schmoe\&quot;);     builder.add(\&quot;DATE_OF_BIRTH\&quot;, \&quot;03-SEP-1987\&quot;);     JsonObject searchCriteria &#x3D; builder.build();      String searchAttrs &#x3D; searchCriteria.toString();     String encodedAttrs &#x3D; URLEncoder.encode(searchAttrs, \&quot;UTF-8\&quot;);     String urlPath &#x3D; \&quot;/entities?attrs&#x3D;\&quot; + encodedAttrs;   &#x60;&#x60;&#x60;  In both of the above examples the &#x60;urlPath&#x60; variable is set to: &#x60;&#x60;&#x60;json  /entities?attrs&#x3D;%7B%22NAME_FULL%22%3A%22Joe%20Schmoe%22%2C%22DATE_OF_BIRTH%22%3A%2203-SEP-1987%22%7D  &#x60;&#x60;&#x60;
     * @param attr Either the &#x60;attrs&#x60; or &#x60;attr&#x60; parameter is required, **however** if the &#x60;attrs&#x60; parameter is provided it takes precedence and the &#x60;attr&#x60; parameter will be ignored.  If you are using this API programmatically then you should typically use the &#x60;attrs&#x60; parameter.  But when manually constructing a URL in the browser address bar, in a command-line tool like &#x60;curl&#x60; or in a REST client browser extension for debugging or testing purposes, encoding that JSON value can be unwieldy.  This parameter (which is multi-valued) lets you specify colon-delimited strings that are prefixed with the JSON property name and suffixed with the value.  For example, &#x60;NAME_FIRST:Joe&#x60; (url encoded of course).  This side-steps the need to URL-encode the structural JSON characters and usually means you need only URL-encode basic characters like colons (&#x60;%3A&#x60;) and spaces (&#x60;%20&#x60;).  The JSON constructed using this parameter is obviously flat.  If you want to group properties together by their \&quot;usage type\&quot; (e.g.: &#x60;NAME_TYPE&#x60;, &#x60;PHONE_TYPE&#x60; or &#x60;ADDRESS_TYPE&#x60;) then you would **also** prefix with the type (e.g.: &#x60;HOME_PHONE_NUMBER:702-555-1212&#x60;).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - Group near-duplicate feature values and return                         a representative value along with its near                         duplicate values.
     * @param withFeatureStats Set to &#x60;true&#x60; to include resolution statistics for features.  This defaults to &#x60;false&#x60;.
     * @param withInternalFeatures Set to &#x60;true&#x60; to include \&quot;expressed\&quot; features that are derived composite keys such as name + date of birth keys.  This defaults to &#x60;false&#x60;.
     * @param forceMinimal Whether or not to force the minimum entity detail in the response which may consist of nothing more than an entity ID.  This provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  This overrules other parameters governing the retrieval of features or related entities.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchByAttributes(attrs?: string, attr?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzAttributeSearchResponse>;
    public searchByAttributes(attrs?: string, attr?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzAttributeSearchResponse>>;
    public searchByAttributes(attrs?: string, attr?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzAttributeSearchResponse>>;
    public searchByAttributes(attrs?: string, attr?: Array<string>, featureMode?: SzFeatureMode, withFeatureStats?: boolean, withInternalFeatures?: boolean, forceMinimal?: boolean, withRelationships?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {
        return this.searchEntitiesByGet(attrs, attr, undefined, undefined, featureMode, withFeatureStats, withInternalFeatures, forceMinimal, withRelationships, withRaw, observe, reportProgress, additionalHeaders);
    }

    /**
     * Returns an analysis of why the two entities related, did not relate, or did not resolve.
     * This operation provides an anlysis of why two entities related, did not relate or did not resolve.  The entities are identified either by entity ID&#x27;s or by data source code and record ID pairs for constituent records of those entities.  **NOTE:** If the first entity is identified by entity ID then the second must also be identified an entity ID.  Similarly, if the first entity is identified by data source code and record ID then the second must also be identified by data source code and record ID.  **ALSO NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve. 
     * @param entity1 The &#x60;SzEntityIdentifier&#x60; for the first entity as an entity ID or an encoded &#x60;SzRecordId&#x60; for the constituent record.  Whatever format is used for the \&quot;entity1\&quot; parameter must match the format of the \&quot;entity2\&quot; parameter.  NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param entity2 The &#x60;SzEntityIdentifier&#x60; for the second entity as an entity ID or an encoded &#x60;SzRecordId&#x60; for the constituent record.  Whatever format is used for the \&quot;entity2\&quot; parameter must match the format of the \&quot;entity1\&quot; parameter.  NOTE: An encoded &#x60;SzRecordId&#x60; can EITHER be encoded as JSON or as a delimited string where the first character is the delimiter and the remainder is parsed as a data source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all characters after the second occurrence of the delimiter).  For example: &#x60;{\&quot;src\&quot;:\&quot;PEOPLE\&quot;,\&quot;id\&quot;:\&quot;12345ABC\&quot;}&#x60; or &#x60;:PEOPLE:12345ABC&#x60;.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withFeatureStats Set to &#x60;false&#x60; to suppress resolution statistics for features.  This defaults to &#x60;true&#x60; for why operations.
     * @param withInternalFeatures Set to &#x60;false&#x60; to suppress \&quot;expressed\&quot; features that are derived composite keys such as &#x60;FULL_NAME&#x60; + &#x60;DATE_OF_BIRTH&#x60;.  This defaults to &#x60;true&#x60; for why operations.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public whyEntities(entity1: string, entity2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzWhyEntitiesResponse>;
    public whyEntities(entity1: string, entity2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzWhyEntitiesResponse>>;
    public whyEntities(entity1: string, entity2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzWhyEntitiesResponse>>;
    public whyEntities(entity1: string, entity2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entity1 === null || entity1 === undefined) {
            throw new Error('Required parameter entity1 was null or undefined when calling whyEntities.');
        }

        if (entity2 === null || entity2 === undefined) {
            throw new Error('Required parameter entity2 was null or undefined when calling whyEntities.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (entity1 !== undefined && entity1 !== null) {
            queryParameters = queryParameters.set('entity1', <any>entity1);
        }
        if (entity2 !== undefined && entity2 !== null) {
            queryParameters = queryParameters.set('entity2', <any>entity2);
        }
        if (withRelationships !== undefined && withRelationships !== null) {
            queryParameters = queryParameters.set('withRelationships', <any>withRelationships);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzWhyEntitiesResponse>('get',`${this.basePath}/why/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an analysis of why the entity for the respective entity ID resolved.
     * This operation provides an anlysis of why the records in an entity resolved.  The subject entity is identified by the entity ID in the request path.  **NOTE:** Bear in mind that entity ID&#x27;s are transient and may be recycled or repurposed as new records are loaded and entities resolve, unresolve and re-resolve.  An alternative way to identify an entity is by one of its constituent records using &#x60;GET /data-sources/{dataSourceCode}/records/{recordId}/entity/why&#x60;. 
     * @param entityId The unique numeric ID that identifies that entity being requested.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withFeatureStats Set to &#x60;false&#x60; to suppress resolution statistics for features.  This defaults to &#x60;true&#x60; for why operations.
     * @param withInternalFeatures Set to &#x60;false&#x60; to suppress \&quot;expressed\&quot; features that are derived composite keys such as &#x60;FULL_NAME&#x60; + &#x60;DATE_OF_BIRTH&#x60;.  This defaults to &#x60;true&#x60; for why operations.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public whyEntityByEntityID(entityId: number, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzWhyEntityResponse>;
    public whyEntityByEntityID(entityId: number, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzWhyEntityResponse>>;
    public whyEntityByEntityID(entityId: number, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzWhyEntityResponse>>;
    public whyEntityByEntityID(entityId: number, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityId === null || entityId === undefined) {
            throw new Error('Required parameter entityId was null or undefined when calling whyEntityByEntityID.');
        }






        
        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRelationships !== undefined && withRelationships !== null) {
            queryParameters = queryParameters.set('withRelationships', <any>withRelationships);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzWhyEntityResponse>('get',`${this.basePath}/entities/${encodeURIComponent(String(entityId))}/why`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an analysis of why the entity for the record with the respective data source code and record ID resolved.
     * This operation provides an anlysis of why the records in an entity resolved.  The subject entity is the one containing the record identified by the data source code and record ID in the request path. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withFeatureStats Set to &#x60;false&#x60; to suppress resolution statistics for features.  This defaults to &#x60;true&#x60; for why operations.
     * @param withInternalFeatures Set to &#x60;false&#x60; to suppress \&quot;expressed\&quot; features that are derived composite keys such as &#x60;FULL_NAME&#x60; + &#x60;DATE_OF_BIRTH&#x60;.  This defaults to &#x60;true&#x60; for why operations.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public whyEntityByRecordID(dataSourceCode: string, recordId: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzWhyEntityResponse>;
    public whyEntityByRecordID(dataSourceCode: string, recordId: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzWhyEntityResponse>>;
    public whyEntityByRecordID(dataSourceCode: string, recordId: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzWhyEntityResponse>>;
    public whyEntityByRecordID(dataSourceCode: string, recordId: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling whyEntityByRecordID.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling whyEntityByRecordID.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRelationships !== undefined && withRelationships !== null) {
            queryParameters = queryParameters.set('withRelationships', <any>withRelationships);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzWhyEntityResponse>('get',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}/entity/why`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an analysis of why the records identified by the data source and record ID&#x27;s in the query parameters resolved or did not resolve.
     * This operation provides an anlysis of two records identified by data source code and record ID in respective qeury parameters resolved or did not resolve. 
     * @param dataSource1 The data source for the first record.
     * @param recordId1 The record ID for the first record.
     * @param dataSource2 The data source for the second record.
     * @param recordId2 The data source for the second record.
     * @param withRelationships Set to &#x60;true&#x60; to include partial information of related entities for the returned entities.  This defaults to &#x60;false&#x60;.
     * @param withFeatureStats Set to &#x60;false&#x60; to suppress resolution statistics for features.  This defaults to &#x60;true&#x60; for why operations.
     * @param withInternalFeatures Set to &#x60;false&#x60; to suppress \&quot;expressed\&quot; features that are derived composite keys such as &#x60;FULL_NAME&#x60; + &#x60;DATE_OF_BIRTH&#x60;.  This defaults to &#x60;true&#x60; for why operations.
     * @param detailLevel Specifies the level of detail desired for the entity data.  Details for features of entities as well as the related entities of entities are controlled by &#x60;featureMode&#x60;, &#x60;withInternalFeatures&#x60;, and &#x60;withFeatureStats&#x60;.  If not specified the value defaults to &#x60;VERBOSE&#x60;. Possible values are:   * &#x60;MINIMAL&#x60; - The entities returned will include at most their                 entity ID&#x27;s as well as identifiers for their                 constituent records (i.e.: data source code and record                 ID for each record).  This detail level is optimized for                 the fastest possible processing time.   * &#x60;BRIEF&#x60; - Builds upon &#x60;MINIMAL&#x60; to add the entity name and related               entity match info when related entity match info when               related entities are included.  This detail level aims to               maintain as much speed as possible while providing names               and relationship information for rendering a graph.   * &#x60;SUMMARY&#x60; - Identical to &#x60;BRIEF&#x60; except that individual record                 identifier information is excluded, leaving only the                 record summary (i.e.: a record count by data source                 code).  This reduces the size of the JSON document for                 large entities with thousands of records.  It may take                 longer to process than &#x60;BRIEF&#x60; but less data is                 returned as well, speeding up network transfer times.   * &#x60;VERBOSE&#x60; - Combines &#x60;BRIEF&#x60; and &#x60;SUMMARY&#x60; and then adds the                 original JSON data for each record, the record-level                 matching info, as well as formatted record data.  NOTE:                 the record-level matching info returned via \&quot;how\&quot; and                 \&quot;why\&quot; is often more useful than that embedded in the                 entity.  Further, the formatted record data, while                 readable, is not formatted according to locale (i.e.:                 address, name and date formatting may not appear as                 expected to a user).
     * @param featureMode The method by which feature values should be included for entities returned in the response.  The possible values are:   * &#x60;NONE&#x60; - Do not include any feature values -- this is the fastest              option from a performance perspective because feature              values do not have to be retrieved.   * &#x60;REPRESENTATIVE&#x60; - Include only a single representative value per                        \&quot;unique\&quot; value of a feature.  If there are                        multiple values that are near duplicates then                        only one value is included and the others are                        suppressed.   * &#x60;WITH_DUPLICATES&#x60; - ** (default value) ** Group near-duplicate                         feature values and return a representative value                         along with its near duplicate values.   * &#x60;ATTRIBUTED&#x60; - Same as &#x60;WITH_DUPLICATES&#x60; but with record-level                    references attributing each feature to the record(s)                    that provided it for the entity along with any                    usage type that might have been associated with the                    feature at the record level.
     * @param forceMinimal Whether (or not) to force the minimum entity detail in the response which will consist of nothing more than an entity ID and record identifying information (i.e.: data source code and record ID) for each constituent record of an entity.  Unlike &#x60;detailLevel&#x3D;MINIMAL&#x60; setting this to &#x60;true&#x60; precludes the addition of feature information via other parameters.  Setting this to &#x60;true&#x60; provides the fastest response to an entity query operation because no additional data needs to be retrieved other than what is directly accessible.  Setting this parameter to &#x60;true&#x60; overrules other parameters governing the retrieval of features or related entities.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public whyRecords(dataSource1: string, recordId1: string, dataSource2: string, recordId2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzWhyRecordsResponse>;
    public whyRecords(dataSource1: string, recordId1: string, dataSource2: string, recordId2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzWhyRecordsResponse>>;
    public whyRecords(dataSource1: string, recordId1: string, dataSource2: string, recordId2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzWhyRecordsResponse>>;
    public whyRecords(dataSource1: string, recordId1: string, dataSource2: string, recordId2: string, withRelationships?: boolean, withFeatureStats?: boolean, withInternalFeatures?: boolean, detailLevel?: SzDetailLevel, featureMode?: SzFeatureMode, forceMinimal?: boolean, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSource1 === null || dataSource1 === undefined) {
            throw new Error('Required parameter dataSource1 was null or undefined when calling whyRecords.');
        }

        if (recordId1 === null || recordId1 === undefined) {
            throw new Error('Required parameter recordId1 was null or undefined when calling whyRecords.');
        }

        if (dataSource2 === null || dataSource2 === undefined) {
            throw new Error('Required parameter dataSource2 was null or undefined when calling whyRecords.');
        }

        if (recordId2 === null || recordId2 === undefined) {
            throw new Error('Required parameter recordId2 was null or undefined when calling whyRecords.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (dataSource1 !== undefined && dataSource1 !== null) {
            queryParameters = queryParameters.set('dataSource1', <any>dataSource1);
        }
        if (recordId1 !== undefined && recordId1 !== null) {
            queryParameters = queryParameters.set('recordId1', <any>recordId1);
        }
        if (dataSource2 !== undefined && dataSource2 !== null) {
            queryParameters = queryParameters.set('dataSource2', <any>dataSource2);
        }
        if (recordId2 !== undefined && recordId2 !== null) {
            queryParameters = queryParameters.set('recordId2', <any>recordId2);
        }
        if (withRelationships !== undefined && withRelationships !== null) {
            queryParameters = queryParameters.set('withRelationships', <any>withRelationships);
        }
        if (withFeatureStats !== undefined && withFeatureStats !== null) {
            queryParameters = queryParameters.set('withFeatureStats', <any>withFeatureStats);
        }
        if (withInternalFeatures !== undefined && withInternalFeatures !== null) {
            queryParameters = queryParameters.set('withInternalFeatures', <any>withInternalFeatures);
        }
        if (detailLevel !== undefined && detailLevel !== null) {
            queryParameters = queryParameters.set('detailLevel', <any>detailLevel);
        }
        if (featureMode !== undefined && featureMode !== null) {
            queryParameters = queryParameters.set('featureMode', <any>featureMode);
        }
        if (forceMinimal !== undefined && forceMinimal !== null) {
            queryParameters = queryParameters.set('forceMinimal', <any>forceMinimal);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzWhyRecordsResponse>('get',`${this.basePath}/why/records`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
}
