/**
 * Senzing POC REST API
 * This is the Senzing POC REST API.  This API is <b>NOT</b> maintained for backwards compatibility.  This API extends the [Senzing REST API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/Senzing/senzing-rest-api-specification/main/senzing-rest-api.yaml) which is maintained for backwards compatibility.  However, the Senzing POC API is specifically targeted at the Senzing One-Day POC application and no guarantees are made for support.  It can be used as example for creating your own extended API. <br><br> <b>SSE NOTE:</b> Some end-points described here will indicate \"(Supports SSE)\" to indicate that they support \"Server-sent Events\" via the `text/event-stream` media type.  This support is activated by adding the `Accept: text/event-stream` header to a request to override the default `application/json` media type.  Further, the end-point will behave similarly to its standard operation but will produce `progress` events at regular intervals that are equivalent to its `200` response schema. Upon success, the final event will be `completed` with the same response schema as a `200` response.  Upon failure, the final event will be `failed` with same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`) <br><br> <b>WEB SOCKETS NOTE:</b> Some end-points described here will indicate \"(Supports WebSockets)\" to indicate that they can invoked via the Web Sockets protocol. This support is activated by invoking the end-point using the `ws://` protocol in the URL.  Any request query parameters can still be sent on the URL and the request body can be sent as one or more message from the client (as documented).  The end-point response will be sent as one or more response messages as documented (sometimes describing progress as with SSE end-points).  Upon failure responses will follow the same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`)
 *
 * OpenAPI spec version: 3.5.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

 import { Inject, Injectable, Optional }                      from '@angular/core';
 import { HttpClient, HttpHeaders, HttpParams,
          HttpResponse, HttpEvent }                           from '@angular/common/http';
 import { CustomHttpUrlEncodingCodec }                        from '../encoder';
 
 import { Observable }                                        from 'rxjs';
 
 import { SzBoundType } from '../model/szBoundType';
 import { SzCountStatsResponse } from '../model/szCountStatsResponse';
 import { SzEntityRelationsBreakdownResponse } from '../model/szEntityRelationsBreakdownResponse';
 import { SzEntityRelationsCountResponse } from '../model/szEntityRelationsCountResponse';

 import { SzEntitySizeBreakdownResponse } from '../model/szEntitySizeBreakdownResponse';
 import { SzEntitySizeCountResponse } from '../model/szEntitySizeCountResponse';
 import { SzErrorResponse } from '../model/szErrorResponse';
 import { SzPagedEntitiesResponse } from '../model/szPagedEntitiesResponse';
 import { SzSourceCountStatsResponse } from '../model/szSourceCountStatsResponse';
 
 import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
 import { Configuration }                                     from '../configuration';
 
 
 @Injectable()
 export class StatisticsService {
 
     protected basePath = 'http://localhost:8250';
     public defaultHeaders = new HttpHeaders();
     public configuration = new Configuration();
 
     constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
         if (basePath) {
             this.basePath = basePath;
         }
         if (configuration) {
             this.configuration = configuration;
             this.basePath = basePath || configuration.basePath || this.basePath;
         }
     }
 
     /**
      * @param consumes string[] mime-types
      * @return true: consumes contains 'multipart/form-data', false: otherwise
      */
     private canConsumeForm(consumes: string[]): boolean {
         const form = 'multipart/form-data';
         for (const consume of consumes) {
             if (form === consume) {
                 return true;
             }
         }
         return false;
     }
 
 
     /**
      * Gets the entity ID&#x27;s of the entities having the specific number of entity relationships.
      * Gets the entity ID&#x27;s of the entities having the respective number of entity relations.  If no entities have the respective number of entity relations then this will return a 200 OK response that will have an empty array of entity ID&#x27;s rather than giving a 404 Not Found response.  Further, if there are no entity ID&#x27;s having the specified number of entity relations that are greater than the specified minimum entity ID then similarly a 200 OK response is returned but the array of ID&#x27;s contained in the response will be empty. *NOTE*: Data mart statistics may be slightly delayed from the entity repository.        
      * @param relationsCount The number of relationships for the entities of interest.
      * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as bound on the entity ID values returned.  The type of bound is given by the  &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value. To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;. To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of  &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.
      * @param boundType The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the entity ID bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of  entity ID&#x27;s specify the least entity ID value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisifying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisifying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
      * @param pageSize The optional parameter to limit the number of returned results per page.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getEntityIdsForEntityRelations(relationsCount: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzPagedEntitiesResponse>;
     public getEntityIdsForEntityRelations(relationsCount: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzPagedEntitiesResponse>>;
     public getEntityIdsForEntityRelations(relationsCount: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzPagedEntitiesResponse>>;
     public getEntityIdsForEntityRelations(relationsCount: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         if (relationsCount === null || relationsCount === undefined) {
             throw new Error('Required parameter relationsCount was null or undefined when calling getEntityIdsForEntityRelations.');
         }
 
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (bound !== undefined && bound !== null) {
             queryParameters = queryParameters.set('bound', <any>bound);
         }
         if (boundType !== undefined && boundType !== null) {
             queryParameters = queryParameters.set('boundType', <any>boundType);
         }
         if (pageSize !== undefined && pageSize !== null) {
             queryParameters = queryParameters.set('pageSize', <any>pageSize);
         }
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzPagedEntitiesResponse>('get',`${this.basePath}/statistics/relations/${encodeURIComponent(String(relationsCount))}/entities`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the entity ID&#x27;s of the entities having the specific number of records.
      * Gets the entity ID&#x27;s of the entities having the number of records for the specified entity size.  If no entities have the specified number of records then this will return a 200 OK response that will have an empty array of entity ID&#x27;s rather than giving a 404 Not Found response.  Further, if there are no entity ID&#x27;s having the specified number of records that are greater than the specified minimum entity ID then similarly a 200 OK response is  returned but the array of ID&#x27;s contained in the response will be empty. *NOTE*: Data mart statistics may be slightly delayed from the entity repository.        
      * @param entitySize The number of records for the entities of interest.
      * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as bound on the entity ID values returned.  The type of bound is given by the  &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value. To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;. To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of  &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.
      * @param boundType The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the entity ID bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of  entity ID&#x27;s specify the least entity ID value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisifying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisifying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
      * @param pageSize The optional parameter to limit the number of returned results per page.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getEntityIdsForEntitySize(entitySize: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzPagedEntitiesResponse>;
     public getEntityIdsForEntitySize(entitySize: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzPagedEntitiesResponse>>;
     public getEntityIdsForEntitySize(entitySize: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzPagedEntitiesResponse>>;
     public getEntityIdsForEntitySize(entitySize: number, bound?: number, boundType?: SzBoundType, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         if (entitySize === null || entitySize === undefined) {
             throw new Error('Required parameter entitySize was null or undefined when calling getEntityIdsForEntitySize.');
         }
 
 
 
 
         let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
         if (bound !== undefined && bound !== null) {
             queryParameters = queryParameters.set('bound', <any>bound);
         }
         if (boundType !== undefined && boundType !== null) {
             queryParameters = queryParameters.set('boundType', <any>boundType);
         }
         if (pageSize !== undefined && pageSize !== null) {
             queryParameters = queryParameters.set('pageSize', <any>pageSize);
         }
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzPagedEntitiesResponse>('get',`${this.basePath}/statistics/sizes/${encodeURIComponent(String(entitySize))}/entities`,
             {
                 params: queryParameters,
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the entity counts by the number of entity relations (Entity  Relation Breakdown).
      * Gets the number of entities in the repository for each number of entity relations that exists for those entities.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getEntityRelationsBreakdown(observe?: 'body', reportProgress?: boolean): Observable<SzEntityRelationsBreakdownResponse>;
     public getEntityRelationsBreakdown(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntityRelationsBreakdownResponse>>;
     public getEntityRelationsBreakdown(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntityRelationsBreakdownResponse>>;
     public getEntityRelationsBreakdown(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzEntityRelationsBreakdownResponse>('get',`${this.basePath}/statistics/relations`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the count of entities having the specific number of entity relations.
      * Gets the count of entities having the specific number of entity relations. If there are NO entities having the specified number of entity relations then this will return a 200 OK response with the result indicating a count of zero entities rather than giving a 404 Not Found response.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
      * @param relationsCount The number of relationships for the entities of interest.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getEntityRelationsCount(relationsCount: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntityRelationsCountResponse>;
     public getEntityRelationsCount(relationsCount: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntityRelationsCountResponse>>;
     public getEntityRelationsCount(relationsCount: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntityRelationsCountResponse>>;
     public getEntityRelationsCount(relationsCount: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         if (relationsCount === null || relationsCount === undefined) {
             throw new Error('Required parameter relationsCount was null or undefined when calling getEntityRelationsCount.');
         }
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzEntityRelationsCountResponse>('get',`${this.basePath}/statistics/relations/${encodeURIComponent(String(relationsCount))}`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the entity counts by entity size (Entity Size Breakdown).
      * Gets the number of entities in the repository for each entity size  that exists.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getEntitySizeBreakdown(observe?: 'body', reportProgress?: boolean): Observable<SzEntitySizeBreakdownResponse>;
     public getEntitySizeBreakdown(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitySizeBreakdownResponse>>;
     public getEntitySizeBreakdown(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitySizeBreakdownResponse>>;
     public getEntitySizeBreakdown(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzEntitySizeBreakdownResponse>('get',`${this.basePath}/statistics/sizes`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the count of entities having the specific number of records.
      * Gets the count of entities having the specific number of records. If there are NO entities having the specified number of records then this will return a 200 OK response with the result indicating a count of zero entities rather than giving a 404 Not Found response. *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
      * @param entitySize The number of records for the entities of interest.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getEntitySizeCount(entitySize: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitySizeCountResponse>;
     public getEntitySizeCount(entitySize: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitySizeCountResponse>>;
     public getEntitySizeCount(entitySize: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitySizeCountResponse>>;
     public getEntitySizeCount(entitySize: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         if (entitySize === null || entitySize === undefined) {
             throw new Error('Required parameter entitySize was null or undefined when calling getEntitySizeCount.');
         }
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzEntitySizeCountResponse>('get',`${this.basePath}/statistics/sizes/${encodeURIComponent(String(entitySize))}`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the entity and record counts in total and by data source from the data mart.
      * Gets the entity and record counts in total and by data source from the data mart.  *NOTE*: Data mart statistics may be slightly delayed from  the entity repository.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getLoadedStatistics(observe?: 'body', reportProgress?: boolean): Observable<SzCountStatsResponse>;
     public getLoadedStatistics(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzCountStatsResponse>>;
     public getLoadedStatistics(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzCountStatsResponse>>;
     public getLoadedStatistics(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzCountStatsResponse>('get',`${this.basePath}/statistics/loaded`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
     /**
      * Gets the entity and record counts for a specific data source from the data mart.
      * Gets the entity and record counts for a specific data source from the data mart.  *NOTE*: Data mart statistics may be slightly delayed from  the entity repository.
      * @param dataSourceCode The data source code identifying the data source.
      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
      * @param reportProgress flag to report request and response progress.
      */
     public getSourceLoadedStatistics(dataSourceCode: string, observe?: 'body', reportProgress?: boolean): Observable<SzSourceCountStatsResponse>;
     public getSourceLoadedStatistics(dataSourceCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzSourceCountStatsResponse>>;
     public getSourceLoadedStatistics(dataSourceCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzSourceCountStatsResponse>>;
     public getSourceLoadedStatistics(dataSourceCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
 
         if (dataSourceCode === null || dataSourceCode === undefined) {
             throw new Error('Required parameter dataSourceCode was null or undefined when calling getSourceLoadedStatistics.');
         }
 
         let headers = this.defaultHeaders;
 
         // to determine the Accept header
         let httpHeaderAccepts: string[] = [
             'application/json; charset=UTF-8',
             'application/json',
             'default'
         ];
         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
         if (httpHeaderAcceptSelected != undefined) {
             headers = headers.set('Accept', httpHeaderAcceptSelected);
         }
 
         // to determine the Content-Type header
         const consumes: string[] = [
         ];
 
         return this.httpClient.request<SzSourceCountStatsResponse>('get',`${this.basePath}/statistics/loaded/data-sources/${encodeURIComponent(String(dataSourceCode))}`,
             {
                 withCredentials: this.configuration.withCredentials,
                 headers: headers,
                 observe: observe,
                 reportProgress: reportProgress
             }
         );
     }
 
 }
 