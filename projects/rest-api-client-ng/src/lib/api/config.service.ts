/**
 * Senzing REST API
 * This is the Senzing REST API.  It describes the REST interface to Senzing API functions available via REST.  It leverages the Senzing native API which is documented at [https://docs.senzing.com](https://docs.senzing.com). <br><br> <b>NOTE:</b> Some end-points described here will indicate \"(Supports SSE)\" to indicate that they support \"Server-sent Events\" via the `text/event-stream` media type.  This support is activated by adding the `Accept: text/event-stream` header to a request to override the default `application/json` media type.  Further, the end-point will behave the similarly to its stand operation but will produce `progress` events at regular intervals that are equivalent to its `200` response schema. Upon success, the final event will be `completed` with the same response schema as a `200` response.  Upon failure, the final event will be `failed` with same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`) [https://docs.senzing.com](https://docs.senzing.com)
 *
 * OpenAPI spec version: 2.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { DatasourcesBody } from '../model/datasourcesBody';
import { DatasourcesBody1 } from '../model/datasourcesBody1';
import { EntitytypesBody } from '../model/entitytypesBody';
import { EntitytypesBody1 } from '../model/entitytypesBody1';
import { SzAttributeClass } from '../model/szAttributeClass';
import { SzAttributeTypeResponse } from '../model/szAttributeTypeResponse';
import { SzAttributeTypesResponse } from '../model/szAttributeTypesResponse';
import { SzConfigResponse } from '../model/szConfigResponse';
import { SzDataSourceResponse } from '../model/szDataSourceResponse';
import { SzDataSourcesResponse } from '../model/szDataSourcesResponse';
import { SzEntityClassResponse } from '../model/szEntityClassResponse';
import { SzEntityClassesResponse } from '../model/szEntityClassesResponse';
import { SzEntityTypeDescriptor } from '../model/szEntityTypeDescriptor';
import { SzEntityTypeResponse } from '../model/szEntityTypeResponse';
import { SzEntityTypesResponse } from '../model/szEntityTypesResponse';
import { SzErrorResponse } from '../model/szErrorResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ConfigService {
    protected _basePath     = '/';
    public configuration    = new Configuration();
    private _defaultHeaders = new HttpHeaders();

    /**
     * get the basePath from the configuration instance
     * or alternatively fallback to local reference
     */
    public get basePath(): string {
        return this.configuration && this.configuration.basePath ? this.configuration.basePath : this._basePath;
    }
    /**
     * set the local basePath reference
     */
    public set basePath(value: string) {
        this._basePath = value;
    }
    /**
     * get additional headers so we can add them to the default request headers
     */
    private get additionalHeaders(): {[key: string]: string} | undefined {
        return this.configuration && this.configuration.additionalHeaders ? this.configuration.additionalHeaders : undefined;
    }
    /** 
     * the default headers for http requests
     * including any additional headers added to configuration
    */
    public get defaultHeaders() {
        let retVal = this._defaultHeaders;
        let _additionalHeaders = this.additionalHeaders;
        // if additional headers specified merge with defaults
        if(_additionalHeaders) {
            for(let _hKey in _additionalHeaders) {
                retVal = retVal.set(_hKey, _additionalHeaders[_hKey]);
            }
        }
        return retVal;
    }

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds one or more new data sources to the current default configuration and reinitializes with the newly modified configuration.
     * Obtains the current default configuration, adds the specified data sources and sets the modified configuration as the new default configuration -- returning the set of all configured data sources.  **NOTE:** This operation may not be allowed.  Some conditions that might cause this operation to be forbidden are:   1. The server does not have administrative functions enabled.   2. The server is running in \&quot;read-only\&quot; mode.   3. The server is started with a file-based configuration specified      by &#x60;G2CONFIGFILE&#x60; property in the initialziation parameters.   4. The server is started with a specific configuration ID and      therefore cannot modify the configuration and change to a new      configuration. 
     * @param body The optional request body to describe the data sources to be created.
        This can be specified as an alternative to the &#x60;dataSource&#x60; parameter
        or in addition to it.  The content can be an array of string data
        source codes or &#x60;SzDataSource&#x60; objects.  It may also be a plain-text
        unquoted string that is simply a single data source code.
        See the various request body examples.

     * @param dataSource The multi-valued query parameter where each value is a data source code identifying data sources to be created.  If a data source code is specified only via this parameter then the data source ID is generated by the API server -- which is usually fine.  If you want to specify the data source ID, then use the request body instead. 
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDataSources(body?: DatasourcesBody | string, dataSource?: string | Array<string>, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzDataSourcesResponse>;
    public addDataSources(body?: DatasourcesBody | string, dataSource?: string | Array<string>, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzDataSourcesResponse>>;
    public addDataSources(body?: DatasourcesBody | string, dataSource?: string | Array<string>, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzDataSourcesResponse>>;
    public addDataSources(body?: DatasourcesBody | string, dataSource?: string | Array<string>, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (dataSource && (dataSource as Array<string>).forEach) {
          (dataSource as Array<string>).forEach((element) => {
                queryParameters = queryParameters.append('dataSource', <any>element);
            })
        } else if(dataSource && (dataSource as string).toLowerCase) {
          // single string
          queryParameters = queryParameters.set('dataSource', (dataSource as string));
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'text/plain; charset=UTF=8',
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<SzDataSourcesResponse>('post',`${this.basePath}/data-sources`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds one or more new entity types to the current active configuration.
     * Obtains the current active configuration, adds the specified entity types and sets the modified configuration as the new default configuration -- returning the set of all configured entity types.  **NOTE:** This operation may not be allowed.  Some conditions that might cause this operation to be forbidden are:   1. The server does not have administrative functions enabled.   2. The server is running in \&quot;read-only\&quot; mode.   3. The server is started with a file-based configuration specified      by &#x60;G2CONFIGFILE&#x60; property in the initialziation parameters.   4. The server is started with a specific configuration ID and      therefore cannot modify the configuration and change to a new      configuration. 
     * @param body The optional request body to describe the entity types to be created. This can be specified as an alternative to the &#x60;entityType&#x60; parameter or in addition to it.  The content must be an array of string entity type codes or &#x60;SzEntityType&#x60; objects.  It may also be a plain-text unquoted string that is simply a single entity type code.
     * @param entityType The multi-valued query parameter where each value is an entity type code identifying entity types to be created.
     * @param entityClass The optional single-valued query parameter to specify the entity class to use for all created entity types (i.e.: it is associated with all values of &#x60;entityType&#x60; specified).  This defaults to a value of &#x60;ACTOR&#x60; which is the only valid value at this time.  In the future additional values may be allowed.  **NOTE**: In the future, when other values are allowed and if creating entity types with different classes then you can fully described each entity type with its class using an array of &#x60;SzEntityType&#x60; objects in the request body. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
    */
    public addEntityTypes(body?: EntitytypesBody | string, entityType?: string | Array<string>, entityClass?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityTypesResponse>;
    public addEntityTypes(body?: EntitytypesBody | string, entityType?: string | Array<string>, entityClass?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityTypesResponse>>;
    public addEntityTypes(body?: EntitytypesBody | string, entityType?: string | Array<string>, entityClass?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityTypesResponse>>;
    public addEntityTypes(body?: EntitytypesBody | string, entityType?: string | Array<string>, entityClass?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {
        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (entityType && (entityType as Array<string>).forEach) {
          (entityType as Array<string>).forEach((element) => {
                queryParameters = queryParameters.append('entityType', <any>element);
            })
        } else if(entityType) {
          queryParameters = queryParameters.set('entityType', <any>entityType);
        }
        if (entityClass !== undefined && entityClass !== null) {
            queryParameters = queryParameters.set('entityClass', <any>entityClass);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'text/plain; charset=UTF=8',
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        return this.httpClient.request<SzEntityTypesResponse>('post',`${this.basePath}/entity-types`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates one more entity types with the given entity class on the currently active config.
     * This operation will obtain the current default configuration, adds the specified entity types using the given entity class and then set the modified configuration as the new default configuration -- returning the set of all configured entity types.  **NOTE:** Currently the only supported entity class is &#x60;ACTOR&#x60;, but this may change in the future.  **ALSO NOTE:** This operation may not be allowed.  Some conditions that might cause this operation to be forbidden are:   1. The server does not have administrative functions enabled.   2. The server is running in \&quot;read-only\&quot; mode.   3. The server is started with a file-based configuration specified      by &#x60;G2CONFIGFILE&#x60; property in the initialziation parameters.   4. The server is started with a specific configuration ID and      therefore cannot modify the configuration and change to a new      configuration. 
     * @param entityClassCode The entity class code identifying the entity class.  Currently, the only recognized value is &#x60;ACTOR&#x60;.  Other values will yield a 404 error.
     * @param body The optional request body to describe the entity types to be created. This can be specified as an alternative to the &#x60;entityType&#x60; parameter or in addition to it.  The content must be an array of &#x60;SzEntityType&#x60; objects and the entity classes in the &#x60;SzEntityType&#x60; objects must match the entity class in the path.
     * @param entityType The multi-valued query parameter where each value is an entity type code identifying entity types to be created.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addEntityTypesForClass(entityClassCode: string, body?: Array<SzEntityTypeDescriptor> | string, entityType?: Array<string>, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityTypesResponse>;
    public addEntityTypesForClass(entityClassCode: string, body?: Array<SzEntityTypeDescriptor> | string, entityType?: Array<string>, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityTypesResponse>>;
    public addEntityTypesForClass(entityClassCode: string, body?: Array<SzEntityTypeDescriptor> | string, entityType?: Array<string>, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityTypesResponse>>;
    public addEntityTypesForClass(entityClassCode: string, body?: Array<SzEntityTypeDescriptor> | string, entityType?: Array<string>, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityClassCode === null || entityClassCode === undefined) {
            throw new Error('Required parameter entityClassCode was null or undefined when calling addEntityTypesForClass.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        /**
        if (entityType !== undefined && entityType !== null) {
            if((entityClassCode as string[]).length > 0) {
                (entityClassCode as string[]).forEach( (entityClassCodeStr: string) => {
                    queryParameters = queryParameters.append('entityType', entityClassCodeStr);
                });
                console.log('ConfigService.addEntityTypesForClass: string[] entity class', queryParameters);

                //queryParameters = queryParameters.set('entityType', <any>(entityClassCode as string[]).join('&ampentityType='));
                //queryParameters = queryParameters.append('entityType', <any>(entityClassCode as string[]).join('&ampentityType='));

            } else {
                console.log('ConfigService.addEntityTypesForClass: single string entity class', queryParameters);
                queryParameters = queryParameters.set('entityType', <any>entityClassCode);
            }
        }
        */
        if (entityType) {
            entityType.forEach((element) => {
                queryParameters = queryParameters.append('entityType', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'text/plain; charset=UTF=8',
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        return this.httpClient.request<SzEntityTypesResponse>('post',`${this.basePath}/entity-classes/${encodeURIComponent(String(entityClassCode))}/entity-types`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current active configuration as raw JSON, no interpretation.
     * This operation returns the JSON configuration that is currently being used by the native Senzing API initialized by the running server.  No processing or interpretation is performed on the JSON.  This may differ from the registered \&quot;default configuration\&quot; which the server would use if no other configuration were provided. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getActiveConfig(observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzConfigResponse>;
    public getActiveConfig(observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzConfigResponse>>;
    public getActiveConfig(observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzConfigResponse>>;
    public getActiveConfig(observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzConfigResponse>('get',`${this.basePath}/configs/active`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the attribute type identified by the attribute code.
     * This operation will provide a description of a single attribute type for the specified attribute type code. 
     * @param attributeCode The attribute code that uniquely identifies the attribute type.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttributeType(attributeCode: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzAttributeTypeResponse>;
    public getAttributeType(attributeCode: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzAttributeTypeResponse>>;
    public getAttributeType(attributeCode: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzAttributeTypeResponse>>;
    public getAttributeType(attributeCode: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (attributeCode === null || attributeCode === undefined) {
            throw new Error('Required parameter attributeCode was null or undefined when calling getAttributeType.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzAttributeTypeResponse>('get',`${this.basePath}/attribute-types/${encodeURIComponent(String(attributeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of configured attribute types.
     * This operation will provide a list of attribute types that are configured.  The client can filter the returned list of attribute types using various query parameters. 
     * @param withInternal Set to &#x60;true&#x60; to include internal attribute types that are generally not mapped by users.  This defaults to false.
     * @param attributeClass If specified, this filters the list of returned attribute types to those of a specific attribute class.  If not specified then no filtering on attribute class is performed and all are returned.
     * @param featureType If specified, this filters the list of returned attribute types to those belonging to a specific feature type.  If not specified then no filtering on feature type is performed and all are returned.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAttributeTypes(withInternal?: boolean, attributeClass?: SzAttributeClass, featureType?: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzAttributeTypesResponse>;
    public getAttributeTypes(withInternal?: boolean, attributeClass?: SzAttributeClass, featureType?: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzAttributeTypesResponse>>;
    public getAttributeTypes(withInternal?: boolean, attributeClass?: SzAttributeClass, featureType?: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzAttributeTypesResponse>>;
    public getAttributeTypes(withInternal?: boolean, attributeClass?: SzAttributeClass, featureType?: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {
        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withInternal !== undefined && withInternal !== null) {
            queryParameters = queryParameters.set('withInternal', <any>withInternal);
        }
        if (attributeClass !== undefined && attributeClass !== null) {
            queryParameters = queryParameters.set('attributeClass', <any>attributeClass);
        }
        if (featureType !== undefined && featureType !== null) {
            queryParameters = queryParameters.set('featureType', <any>featureType);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzAttributeTypesResponse>('get',`${this.basePath}/attribute-types`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the details on the specified data source.
     * This operation provides details on a specific data source identified by the data source code in the requested path. 
     * @param dataSourceCode The data source code identifying the data source.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataSource(dataSourceCode: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzDataSourceResponse>;
    public getDataSource(dataSourceCode: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzDataSourceResponse>>;
    public getDataSource(dataSourceCode: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzDataSourceResponse>>;
    public getDataSource(dataSourceCode: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getDataSource.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzDataSourceResponse>('get',`${this.basePath}/data-sources/${encodeURIComponent(String(dataSourceCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of configured data sources.
     * This operation will provide a list of data source codes as well as a list of detailed descriptions of each data source. 
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDataSources(withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzDataSourcesResponse>;
    public getDataSources(withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzDataSourcesResponse>>;
    public getDataSources(withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzDataSourcesResponse>>;
    public getDataSources(withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzDataSourcesResponse>('get',`${this.basePath}/data-sources`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the details on the specified entity class.  **NOTE:** Currently, the only supported entity class is &#x60;ACTOR&#x60;, but this may change in the future.
     * This operation provides details on a specific entity class identified by the entity class code in the requested path.  **NOTE:** Currently, the only supported entity class is &#x60;ACTOR&#x60;, but this may change in the future. 
     * @param entityClassCode The entity class code identifying the entity class.  Currently, the only recognized value is &#x60;ACTOR&#x60;.  Other values will yield a 404 error.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityClass(entityClassCode: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityClassResponse>;
    public getEntityClass(entityClassCode: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityClassResponse>>;
    public getEntityClass(entityClassCode: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityClassResponse>>;
    public getEntityClass(entityClassCode: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityClassCode === null || entityClassCode === undefined) {
            throw new Error('Required parameter entityClassCode was null or undefined when calling getEntityClass.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityClassResponse>('get',`${this.basePath}/entity-classes/${encodeURIComponent(String(entityClassCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of configured entity classes.  Currently, the only supported entity class is &#x60;ACTOR&#x60;.
     * This operation will provide a list of entity class codes as well as a list of detailed descriptions of each entity class.  **NOTE:** Currently, the only supported entity class is &#x60;ACTOR&#x60;, though others may be supported in the future. 
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityClasses(withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityClassesResponse>;
    public getEntityClasses(withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityClassesResponse>>;
    public getEntityClasses(withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityClassesResponse>>;
    public getEntityClasses(withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityClassesResponse>('get',`${this.basePath}/entity-classes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the details on the specified entity type.
     * This operation provides details on a specific entity type identified by the entity type code in the requested path. 
     * @param entityTypeCode The entity type code identifying the entity type.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityType(entityTypeCode: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityTypeResponse>;
    public getEntityType(entityTypeCode: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityTypeResponse>>;
    public getEntityType(entityTypeCode: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityTypeResponse>>;
    public getEntityType(entityTypeCode: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityTypeCode === null || entityTypeCode === undefined) {
            throw new Error('Required parameter entityTypeCode was null or undefined when calling getEntityType.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityTypeResponse>('get',`${this.basePath}/entity-types/${encodeURIComponent(String(entityTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the details on the specified entity type.
     * This operation provides details on a specific entity type identified by the entity type code in the requested path.  The entity type must have the entity class identified by the entity class code in the request path as well.  **NOTE:** Currently the only supported entity class is &#x60;ACTOR&#x60;, but this may change in the future. 
     * @param entityClassCode The entity class code identifying the entity class.  Currently, the only recognized value is &#x60;ACTOR&#x60;.  Other values will yield a 404 error.
     * @param entityTypeCode The entity type code identifying the entity type.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityTypeByClass(entityClassCode: string, entityTypeCode: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityTypeResponse>;
    public getEntityTypeByClass(entityClassCode: string, entityTypeCode: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityTypeResponse>>;
    public getEntityTypeByClass(entityClassCode: string, entityTypeCode: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityTypeResponse>>;
    public getEntityTypeByClass(entityClassCode: string, entityTypeCode: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityClassCode === null || entityClassCode === undefined) {
            throw new Error('Required parameter entityClassCode was null or undefined when calling getEntityTypeByClass.');
        }

        if (entityTypeCode === null || entityTypeCode === undefined) {
            throw new Error('Required parameter entityTypeCode was null or undefined when calling getEntityTypeByClass.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityTypeResponse>('get',`${this.basePath}/entity-classes/${encodeURIComponent(String(entityClassCode))}/entity-types/${encodeURIComponent(String(entityTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of configured entity types.
     * This operation will provide a list of entity type codes as well as a list of detailed descriptions of each entity type. 
     * @param entityClass If specified, this filters the list of returned entity types to those having the specified entity class.  If not specified then no filtering on entity class is performed and all are returned.  At this time, the only supported entity class is &#x60;ACTOR&#x60;, however, in the future this will change.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityTypes(entityClass?: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityTypesResponse>;
    public getEntityTypes(entityClass?: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityTypesResponse>>;
    public getEntityTypes(entityClass?: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityTypesResponse>>;
    public getEntityTypes(entityClass?: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (entityClass !== undefined && entityClass !== null) {
            queryParameters = queryParameters.set('entityClass', <any>entityClass);
        }
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityTypesResponse>('get',`${this.basePath}/entity-types`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of configured entity types for an entity class. **NOTE:** Currently the only supported entity class is &#x60;ACTOR&#x60;, but this may change in the future.
     * This operation will provide a list of entity type codes as well as a list of detailed descriptions of each entity type that has the entity class identified by the entity class in the request path.  **NOTE:** Currently the only supported entity class is &#x60;ACTOR&#x60;, but this may change in the future. 
     * @param entityClassCode The entity class code identifying the entity class.  Currently, the only recognized value is &#x60;ACTOR&#x60;.  Other values will yield a 404 error.
     * @param withRaw Whether or not to include the raw JSON response from the underlying native API.  This raw response may include additional details but lack some of the abstraction the standard response provides.  If true, then the &#x27;rawData&#x27; field in the response will be a non-null value and contain the additional details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityTypesByClass(entityClassCode: string, withRaw?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzEntityTypesResponse>;
    public getEntityTypesByClass(entityClassCode: string, withRaw?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzEntityTypesResponse>>;
    public getEntityTypesByClass(entityClassCode: string, withRaw?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzEntityTypesResponse>>;
    public getEntityTypesByClass(entityClassCode: string, withRaw?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        if (entityClassCode === null || entityClassCode === undefined) {
            throw new Error('Required parameter entityClassCode was null or undefined when calling getEntityTypesByClass.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withRaw !== undefined && withRaw !== null) {
            queryParameters = queryParameters.set('withRaw', <any>withRaw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityTypesResponse>('get',`${this.basePath}/entity-classes/${encodeURIComponent(String(entityClassCode))}/entity-types`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the base template configuration as raw JSON, no interpretation. This is the initial configuration for a new repository.
     * This operation returns a template base JSON configuration that can be modified or customized by the caller.  The returned template is according to the underlying native Senzing API and may change between version upgrades to Senzing.  No processing or interpretation is performed on the JSON.  This will likely differ from the registered \&quot;default configuration\&quot; or currently \&quot;active configuration\&quot; being used by the running API server. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTemplateConfig(observe?: 'body', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<SzConfigResponse>;
    public getTemplateConfig(observe?: 'response', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpResponse<SzConfigResponse>>;
    public getTemplateConfig(observe?: 'events', reportProgress?: boolean, additionalHeaders?: {[key: string]: string}): Observable<HttpEvent<SzConfigResponse>>;
    public getTemplateConfig(observe: any = 'body', reportProgress: boolean = false, additionalHeaders: {[key: string]: string} = {} ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        if(additionalHeaders) {
            for(let _hKey in additionalHeaders) {
                headers = headers.set(_hKey, additionalHeaders[_hKey]);
            }
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzConfigResponse>('get',`${this.basePath}/configs/template`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
